---
title: 深度理解浏览器从访问url到页面展示的全过程
date: 2022-04-29 14:48:13
tags: 浏览器
categories: 
- 浏览器 
---
# 浏览器的多进程架构
因为js是单线程的，一个线程可以有多个进程
浏览器的三大主要进程：
1. 浏览器进程
主要负责用户交互、子进程管理和文件存储等功能
2. 网络进程
面向渲染进程和浏览器进程等提供网路下载功能
3. 渲染进程
把从网络下载的资源文件解析为可以显示和交互的页面。因为渲染进程里面所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对操作系统进行攻击，所以运行在渲染进程里面的代码是被不信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，为了保证系统的安全。

# 整个过程的大体描述
* 首先用户从浏览器进程里输入请求信息
* 然后网络进程向服务器发起 URL 请求
* 服务器响应 URL 请求后，浏览器进程开始准备渲染进程
* 渲染进程准备好之后，需要向渲染进程提交待渲染的资源文档，提交文段阶段
* 渲染进程接收到文档后，便开始解析页面和加载子资源，完成页面的渲染
* 完成页面的渲染后，将渲染的图片交给浏览器进程，浏览器进程负责展示
  
# 从输入 URL 到页面展示的具体细节
1. URL请求过程
浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程
首先，网络进程基于http缓存协议去执行该Url的请求
如果已经存在该资源且资源没有过期，则直接返回（命中强缓存）
如果没有或者已过期，则发起网络请求：
* 已过期，服务器发现该请求资源没有更新，则返回304，浏览器则取本地资源并更新
* 已过期，服务器发现该请求资源已经更新，则返回200，携带最新资源给浏览器
* 没有 则直接请求
浏览器缓存控制三种方式（Expires、Last-Modified、Etag）
* 第一次请求http响应头会有Last-Modified标记文件在服务器端最后被修改的时间。
* 浏览器第二次请求上次请求过的url时，浏览器会在HTTP请求头添加一个If-Modified-Since的标记，用来询问服务器该时间之后文件是否被修改过
  
Etag 主要为了解决 Last-Modified 无法解决的一些问题:
* 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
* 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
* 某些服务器不能精确的得到文件的最后修改时间；

浏览器是通过last-Modified Expires Etag控制缓存

第二次请求相同的资源的时候
* 有缓存，过期了， 则判断Etag ？ 带If-None-Match ：判断last-Modified
判断 last-Modified ？ 带If-Modified-Since ： 发请求
根据服务器判断资源更新返回304或者200
* 缓存没有过期，则直接使用

# 根据响应的数据类型进行处理
浏览器会根据响应头中的 Content-Type 字段，来决定如何显示响应体的内容。
* 如果是HTML，那么浏览器会继续进行页面渲染，需要准备渲染进程
默认情况下，Chrome 会为每个页面分配一个渲染进程，即每打开一个新页面，Chrome就会创建分配一个新的渲染进程，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。Chrome 的默认策略是，每个标签对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的化，那么新页面会复用父页面的渲染进程。process-per-site-instance

# 渲染阶段
浏览器的渲染过程主要分为五个步骤：
1. 浏览器将获取的 HTML 文档解析成 DOM 树；
2. 处理 CSS 标记，构成层叠样式表模型（CSSOM）；
3. 将 DOM 和 CSSOM 合并为渲染树（rendering tree）；
4. 根据渲染树上的元素布局 layout
5. 将渲染树上的各个节点绘制到屏幕上，称之为 绘制painting；

# 构建 DOM 树
* DOM 树的构建可能会被 CSS 和 JS 的加载而阻塞；
* display: none 的元素也会在 DOM 树中；
* 注释也会在 DOM 树中；
* script 标签也会在 DOM 树中；
  
# 解析 CSS
浏览器会解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都会被解析成 StyleSheet 对象，每个对象都包括 CSS 规则，CSS规则对象包括对应的选择器和声明对象以及其他对象；
* CSS 的解析可以与 DOM 的解析同步进行（因为渲染树需要Dom和CSSOM一起合成，所以无论哪个都会阻塞dom的渲染）
* CSS 的解析与 script 的执行互斥
* 在 Webkit 内核中进行了 script 执行优化，只有在 JS 访问 CSS 时才会发生互斥 

# 构建渲染树
根据 DOM 树和 CSS 规则树，浏览器就可以构建渲染树了。浏览器首先遍历 DOM 树上的每一个可见节点，然后对每个可见节点找到匹配的 CSS 样式规则并应用
1. 渲染树和 DOM 树不完全对对应；
2. display: none 的元素不在渲染树中；
3. visiblity: none 的元素在渲染树中；

# 渲染树布局
布局阶段浏览器会遍历渲染树的所有节点，由于每个节点都是一个render对象，都包含宽高、位置、背景等样式信息，所以浏览器就能根据这写信息来确定元素在页面中的所在位置，及其样式；
1. float 元素、absolute 元素、fixed 元素会发生位置偏移；
2. 脱离标准文档流就是脱离渲染树（render tree）；所以一些动画元素可以让其脱离渲染树，通过absolute等方式
   
# 渲染树的绘制
绘制阶段，浏览器遍历所有的渲染树节点，调用 paint() 方法，将其渲染在屏幕上。渲染树的绘制工作是由浏览器的UI后端组件完成的。

# 浏览器渲染过程可能出现的事情
* 阻塞渲染
浏览器会延迟 JavaScript 的执行和 DOM 的构建，
1. CSS 被默认为阻塞渲染的资源，所以在 CSSOM 构建完成之前不会处理任何已处理的内容；
2. JavaScript 可以读取和修改 DOM 属性，还可读取和修改 CSSOM 属性，所以 CSS 解析和 script 的执行互斥
因此，script标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则： 
1. 在引入顺序上，CSS 资源先于 JavaScript 资源；
2. JavaScript 尽量少去影响 DOM 的构建；
   
*  回流和重绘（ reflow 和 repaint ）
display:none 会触发 reflow；
visibility: hidden 不会触发 reflow，只会触发 repaint；

# 优化渲染效率建议

1. 合法地去书写 HTML 和 CSS ，且不要忘了文档编码类型；
2. 样式文档应该在 head 标签中，而脚本文档应该在 body 结束之前，防阻塞；
3. 优化 CSS 选择器，尽量少嵌套；
4. 减少 JavaScript 对 DOM 的操作；
5. 修改元素的样式时，修改 class 是性能最高的方法；
6. 尽量用 transform 来做形变和位移
   
# 总结
从输入Url -》 dns解析 -》http请求，响应-》页面渲染
这里最主要就是http请求响应与页面渲染
http请求响应又分3次握手4次挥手协议，与http请求缓存
页面渲染 -》多个进程一起工作 -》事件循环机制 -》 回流重绘 -》
多个进程： 
* 浏览器主进程
* GPU进程
* 渲染进程
事件循环机制：（又分宏任物和微任务）
同步任务在JS线程上优先执行，形成一个执行栈
JS的异步是通过回调函数来实现的，JS只有一个执行线程。 通过把回调函数添加到任务队列中来实现
执行步骤：
1. 先执行执行栈中的同步任务
2. 异步任务放入任务队列
3. 同步任务执行完毕，从任务队列中读取异步任务，进入执行栈，开始执行
异步任务的主要类型：（又分宏任物和微任务） 微任务优先执行
1、普通事件 如click resize 等
2、资源加载 如load error 等
3、定时器 setInterval 等
这些都是宏任物
ajax async属于微任务

渲染进程的组成： 
1. GUI渲染线程，构建DOM树，构建CSSOM，两者合成渲染树，然后绘制在页面上。
2. JS引擎线程（V8引擎）由于js是单线程，依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。
3. 事件触发线程，定时器触发线程，异步HTTP请求线程
  
GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载
JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。
因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系。
当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。

浏览器渲染的图层一般包含两大类：普通图层以及复合图层
可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源
translate3d、translateZ， z-index 都可以加速




