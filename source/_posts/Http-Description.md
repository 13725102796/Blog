---
title: Http版本区别与用户认证
date: 2018-04-12 13:49:53
tags: Http Https Session Cookie Token
categories: 
- 浏览器 
---
# [Http版本区别与用户认证]() 
HTTP协议(HyperTextTransferProtocol超文本传输协议)基于TCP/IP通信协议来传递数据
# 内容摘要：
* Http版本
* Session Cookie
* Token
* 单点登陆
* 浏览器的缓存机制

## **Http版本**
### HTTP/1.0
#### 每次请求都会打开一个新的TCP链接，收到响应后立即断开

### HTTP/1.1（增加了缓存控制策略）
#### 1.0主要用Last-Modified和Expires做缓存判断，1.1引入了更多，如:Etag Cache-Control keep-alive 
#### 1.1默认开启持久连接（同一个TCP连接发送和接受多个http请求/应答），1.0需要手动开启connection:true
#### http pipeline(管道化)，允许在持久连接上可选地使用请求管道。在响应到达之前，可以将多条请求放入队列。当第一条请求通过网络流向服务器时，第二、第三条请求也可以开始发送。在高时延网络条件下，可以减低网络的环回时间提高性能
#### 致命缺点(目前大部分浏览器和Web服务器，都关闭了管道化，采用非管道化模式)
#### **造成队头阻塞，前一个响应未及时返回，后面的响应会被阻塞**
#### 非管道化:完全串行执行，后一个请求必须在前一个响应之后发送，阻塞发生在客户端，http请求阻塞

#### 管道化:请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。因没有序号表明顺序，只能串行接受。阻塞发生在服务端，http响应阻塞
#### 管道化的限制。只有幂等的请求比如 GET、HEAD 才能使用 pipelining
### **解决:**
#### 并发TCP连接(浏览器一个域名采用6-8个TCP链接，并发卜请求) 一般中小型网站基本用不上，一个页面最多就2-3个接口
#### 域名分片(多个域名，可以建立更多的TCP链接，从而提高LTT请求的并发)

### Http2.0 （引入帧和流）
#### 新的二进制格式。 1.x基于文本
#### 2.0方式(多路复用特性) 将多个请求复用同一个tcp通道中，通过二进制分帧并且给每个帧打上流的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID 拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题
#### 头部压缩 使用encoder压缩
#### 服务端推送，把客户端index.html需要的资源推送到浏览器并存在缓存中，等index加载时直接会优先读取缓存，而不用向服务器发起请求了

#### **缺陷：** 为了向下兼容，服务端需要确认客户端是http1.x还是2.0，多做了一次TLS链接
#### 多个请求是在同一个 TCP 管道中，这样当 HTTP 2.0 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP。连接中的所有请求。

## **Session Cookie**
#### Session 是存储在服务器端的文件里面，借助请求的响应在cookie上携带sessionId，服务器存在有一个sessionId与userId的映射表
#### 在多机部署的情况下，可用redies做中间层，缓存session，缺点是所有请求都要去redis获取session，为保障redies高可用性，必须做集群
#### Cookie 在发起请求和响应请求都会携带已存在的数据往返

## **Token**
#### Token是由前端缓存在浏览器一段密文，一般通过设置请求头传递给后端，后端经过JWT去认证

## **单点登陆**
#### 简称SSO，一般定义在多个应用系统中，用户只需登陆一次就可以访问所有互相信任的应用系统
#### 一般是由登陆中间层应用去控制用户的登陆，一旦登陆成功，以后其它系统携带该用户信息访问进来时重定向并携带该用户的token返回去，再用当前应用系统验证token，向客户端响应当前用户信息

## **浏览器缓存**
#### Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。
#### 浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容
#### HTTP 缓存术语：
#### * 缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。
#### * 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。通常过期内容不能用于回复客户端的请求，必须重新向源服务器请求新的内容或者验证缓存的内容是否仍然准备。
#### * 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。
#### * 失效：失效就是把内容从缓存中移除。当内容发生改变时就必须移除失效的内容。
#### 浏览器缓存主要是 HTTP 协议定义的缓存机制。HTML meta 标签，例如
``` bash
<META HTTP-EQUIV="Pragma" CONTENT="no-store">
```
#### 含义是让浏览器不缓存当前页面。但是代理服务器不解析 HTML 内容，一般应用广泛的是用 HTTP 头信息控制缓存
#### 浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：
#### 1. 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。（强缓存）
#### 2. 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）
#### 3. 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）
#### 命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。
#### **疑问解答**
#### 为什么我更新我更新前端资源文件，从新打开链接需要刷新一下才能生效呢？
#### 因为这时候由于你客户端近期在你更新之前是已经访问过该链接，而且缓存过期时间还没失效，这时候命中的是强缓存，当刷新网页时，跳过强缓存，但是会检查协商缓存；浏览器会将资源加载请求发送到服务器，服务器检测到当前加载资源已更新，则将完整的资源返回给浏览器。
#### 强制刷新页面，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。

#### Dom Storage 存储机制
#### sessionStorage浏览器缓存（浏览器关闭则移除） 和 localStorage本地存储（不清楚则永久存在）（5M）
#### 应用场景： 页面意外关闭的数据恢复
#### Application Cache 机制
#### 浏览器在首次加载 HTML 文件时，会解析 manifest 属性，`<html manifest="demo_html.appcache">` 并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。（一般游戏的应用的比较多）
``` bash
CACHE MANIFEST
# 2012-02-21 v1.0.0
/theme.css
/logo.gif
/main.js
 
NETWORK:
login.asp
 
FALLBACK:
/html/ /offline.html 
```
#### AppCache 在首次加载生成后，也有更新机制。被缓存的文件如果要更新，需要更新 manifest 文件。因为浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。发现有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制。

### **移动端 Web 加载性能（缓存）优化**
#### 通过对一些 H5页面进行调试及抓包发现，每次加载一个 H5页面，都会有较多的请求。除了 HTML 主 URL 自身的请求外，HTML外部引用的 JS、CSS、字体文件、图片都是一个独立的 HTTP 请求，每一个请求都串行的（可能有连接复用）。这么多请求串起来，再加上浏览器解析、渲染的时间，Web 整体的加载时间变得较长；请求文件越多，消耗的流量也会越多。我们可综合使用上面说到几种缓存机制，来帮助我们优化 Web 的加载性能。




















