---
title: JS浏览器事件循环机制
date: 2018-05-12 09:48:14
tags: JS BOM
categories: 
- 浏览器 

---
# JavaScript 单线程 非阻塞
定义：单线程（代码执行时只有一个主线程来处理所有任务），非阻塞（当代码需要进行一项异步任务时不会等待，主线程会挂起这个任务，在异步任务返回结果时再执行相应的回调）的脚本语言
用途：与浏览器交互

# 事件循环
用途：js引擎（网页浏览器中专门处理js脚本的虚拟机）实现非阻塞

# 浏览器环境下js引擎的事件循环机制
js代码执行时将不同变量存于内存中的不同位置
堆：放对象 栈：基础类型变量，对象指针

# 执行栈：存放执行环境并依次调用执行的地方
当调用一个方法时，js会生成一个与这个方法对应的执行环境（也叫执行上下文，存放这个方法的私有作用域，上层作用域指向，参数，变量，this对象）。这些方法都被存放在执行栈中，依次调用

# 执行栈执行同步代码
按照执行顺序将执行环境依次加入执行栈中并进入环境执行代码，若有调用，在执行栈中再添加一个执行环境（往上垒），执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并将其销毁，回到上一个方法的执行环境。反复进行，直到代码全部执行完毕

### 执行栈执行异步代码（如发送ajax请求数据）事件队列–实现非阻塞
### js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码…，如此反复，这样就形成了一个无限的循环

### 因为形成了无限循环，所以这个过程被叫做`事件循环`
### 不同的异步任务依据执行优先级被分为两类：微任务（micro task）和宏任务（macro task）
* 宏任务：setInterval() setTimeout()
* 微任务：new Promise() new MutaionObserver() 

### 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行（先微再宏）

