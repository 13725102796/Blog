---
title: JS事件机制与相关问题
date: 2018-04-20 22:45:27
tags: Javascript
categories: 
- 浏览器 

---

## 什么是事件代理/事件委托？
#### 事件代理/事件委托是利用事件冒泡的特性，将本应该绑定在多个元素上的事件绑定在他们的祖先元素上，尤其在动态添加子元素的时候，可以非常方便的提高程序性能，减小内存空间。

## 什么是事件冒泡？什么是事件捕获？
* 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。
* 捕获型事件：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。

#### 在添加事件时用addEventListener(event,fn,useCapture)方法，基中第3个参数useCapture是一个Boolean值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行 Vue 中 @click默认是冒泡的

#### e.stopPropagation() 阻止事件冒泡

## DOM 事件有哪些阶段？谈谈对事件代理的理解
#### 分为三大阶段：捕获阶段--目标阶段--冒泡阶段
#### 事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如'click')，再通过条件判断，执行事件触发后的语句(例如'alert(e.target.innerhtml)')


## 闭包的概念？优缺点？使用场景？
#### 闭包的概念：闭包就是能读取其他函数内部变量的函数。
#### 优点： 避免全局变量的污染，希望一个变量长期存储在内存中（缓存变量）
#### 缺点： 内存泄露（消耗），常驻内存，增加内存使用量
#### 使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。

## new操作符具体干了什么呢?
* 1.创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
* 2.属性和方法被加入到 this 引用的对象中。
* 3.新创建的对象由 this 所引用，并且最后隐式的返回 this 。

## javascript中this的指向
#### this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。
#### 普通的函数调用，函数被谁调用，this就是谁
#### 构造函数的话，如果不用new操作符而直接调用，那即this指向window。用new操作符生成对象实例后，this就指向了新生成的对象。
#### 匿名函数或不处于任何对象中的函数指向window 
#### 如果是call，apply等，指定的this是谁，就是谁。

## Javascript作用链域
#### 作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。

## js如何处理防抖和节流
#### 在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。
``` bash 
# 函数防抖（debounce）：

# 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。

function debounce(fn, wait) { 
  var timeout = null; 
  return function() { 
    if(timeout !== null) clearTimeout(timeout);
    timeout = setTimeout(fn, wait); 
  } 
} 
// 处理函数 
function handle() { console.log(Math.random()); } // 滚动事件
window.addEventListener('scroll', debounce(handle, 1000)); 函数节流函数节流（throttle）：

# 当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。
var throttle = function(func, delay) { 
  var prev = Date.now(); 
  return function() {
    var context = this;
    var args = arguments; 
    var now = Date.now(); 
    if (now - prev >= delay) { 
      func.apply(context, args);
      prev = Date.now(); 
    } 
  } 
}
function handle() { console.log(Math.random()); } 
window.addEventListener('scroll', throttle(handle, 1000));

```

## JS里垃圾回收机制是什么，常用的是哪种，怎么处理的？
#### JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。JS中最常见的垃圾回收方式是标记清除。工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
#### 那些操作会造成内存泄漏
#### 全局变量、闭包、DOM清空或删除时，事件未清除、子元素存在引用

## 什么是虚拟DOM
#### 文档对象模型或 DOM 定义了一个接口，该接口允许 JavaScript 之类的语言访问和操作 HTML 文档。元素由树中的节点表示，并且接口允许我们操纵它们。但是此接口需要付出代价，大量非常频繁的 DOM 操作会使页面速度变慢。为了减少重排和重绘，虚拟dom应运而生。

### JS延迟加载的方式有哪些？
#### defer和async、动态创建DOM方式（用得最多）、按需异步载入JS
* defer：延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。
* async：异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。

## JS为什么要区分微任务和宏任务
* （1）js是单线程的，但是分同步异步
* （2）微任务和宏任务皆为异步任务，它们都属于一个队列
* （3）宏任务一般是：script，setTimeout，setInterval、setImmediate
* （4）微任务：原生Promise
* （5）遇到微任务，先执行微任务，执行完后如果没有微任务，就执行下一个宏任务，如果有微任务，就按顺序一个一个执行微任务









